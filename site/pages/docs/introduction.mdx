# 为什么选择 Viem [关于我们为何构建 Viem 的简要前言]

## 问题

当前低级以太坊接口抽象在以下四个领域中至少存在一个不足：**开发者体验**、**稳定性**、**包大小**、和/或 **性能** — 这是一个四重困境。

作为 [wagmi](https://wagmi.sh) 的作者，一个流行的以太坊 React Hooks 库，我们在使用现有的低级 TypeScript 以太坊库时遇到了困难。我们希望为 wagmi 的用户提供最佳的开发者体验，但受到 wagmi 所基于的底层技术的限制。我们知道，始终稳定、可预测的实现，配合小巧的包大小和高性能的模块，对于与世界上最大的区块链生态系统进行交互至关重要。

因此，我们创建了 **viem**：一个用于以太坊的 TypeScript 接口，提供用于与以太坊交互的低级无状态原语。它是 ethers.js 和 web3.js 的替代品，专注于可靠性、效率和出色的开发者体验。

## 开发者体验

viem 通过模块化和可组合的 API、全面的文档以及自动类型安全和推断，提供了出色的开发者体验。

它为开发者提供了直观的构建块，以构建他们的以太坊应用和库。虽然 viem 的 API 可能比替代库更冗长，但我们认为这是正确的权衡，因为这使得 viem 的模块化构建块极其灵活。易于移动、修改和删除。它还使开发者能够更好地理解以太坊概念，以及理解 _什么_ 和 _为什么_ 某些属性被传递。学习如何使用 viem 是学习如何与以太坊交互的绝佳方式。

我们旨在为 viem 中的 _每个_ 模块提供广泛的 API 文档和使用说明。viem 采用 [文档](https://gist.github.com/zsup/9434452) 和 [测试驱动](<https://en.wikipedia.org/wiki/Test-driven_development#:~:text=Test%2Ddriven%20development%20(TDD),software%20against%20all%20test%20cases.>) 的开发方法来构建模块，这导致了可预测和稳定的 API。

viem 还为消费者提供了 [强类型 API](/docs/typescript)，使消费者能够通过 [自动补全](https://twitter.com/awkweb/status/1555678944770367493)、[类型推断](https://twitter.com/_jxom/status/1570244174502588417?s=20) 以及静态验证获得最佳体验。

## 稳定性

稳定性是 viem 的基本原则。作为 [wagmi](https://wagmi.sh) 的作者，我们有许多大大小小的组织严重依赖该库，并期望它对他们的用户完全稳定。

viem 采取以下措施以确保稳定性：

- 我们在一个分叉的以太坊节点上运行我们的测试套件
- 我们力求实现完全的测试覆盖，并测试所有潜在的行为案例
- 我们构建确定性和纯粹的 API

## 包大小

在构建 Web 应用程序时，保持低包大小至关重要。最终用户不应被要求下载超过 100kB 的模块以与以太坊进行交互。在慢速 3G 移动网络上，加载一个 100kB 的库至少需要 **两秒**（加上建立 HTTP 连接的额外时间）。

此外，viem 是可树摇（tree-shakable）的，这意味着只有你使用的模块才会包含在最终包中。

<div className="h-4"></div>
<img src="/bench-bundlesize.svg" />

## 性能

除了上述快速加载时间外，viem 还通过仅在需要时执行重的异步任务和优化的编码/解析算法进一步提升性能。基准测试不言自明：

<div className="m-auto mt-10 space-y-14 w-10/12">
  <img src="/bench-isaddress.svg" />
  <img src="/bench-parseabi.svg" />
  <img src="/bench-encodeabi.svg" />
</div>

## 偏好与备用选项

与其他强加消费者偏好的低级接口不同，viem 使消费者能够选择自己的偏好，同时保持合理和安全的默认设置。这使得消费者能够创建自己的有偏好的实现，例如 [wagmi](https://wagmi.sh)，而无需繁琐的变通方法。

---

**viem** 将通过类型安全和开发者体验帮助开发者以更高的准确性和正确性进行构建。它还将与 [wagmi](https://wagmi.sh) 极其良好地集成，使人们可以在没有太多前期切换成本的情况下开始使用它。